(** Defn 1.3.2 The set Λ of all λ-terms **)

type term =
  | Var of int
  | App of term * term
  | Abs of term

(** Defn 1.3.5 Multiset of subterms *)
let rec subterms t =
  match t with
  | Var _ -> [t]
  | App (m, n) -> t :: subterms m @ subterms n
  | Abs m -> t :: subterms m
;;

(** Lemma 1.3.6 *)

(** (1) (Reflexivity) For all λ-terms M, we have M ∈ subterms M*)

lemma subterms_refl m =
  List.mem m (subterms m)
;;

lemma mem_append_l x xs ys =
   List.mem x xs ==> List.mem x (xs @ ys)
[@@auto][@@rw]
;;

lemma mem_append_r y xs ys =
   List.mem y ys ==> List.mem y (xs @ ys)
[@@auto][@@rw]
;;

lemma mem_append_b x xs ys =
   List.mem x (xs @ ys) ==> List.mem x xs || List.mem x ys
[@@auto][@@fc]
;;

(** (2) (Transitivity) If L ∈ subterms M and M ∈ subterms N, then L ∈ subterms N *)

lemma subterms_trans l m n =
  List.mem l (subterms m) && List.mem m (subterms n)
  ==>
  List.mem l (subterms n)
[@@auto]
;;

(** Defn 1.3.8 Proper subterm *)

let proper_subterm l m =
  l <> m && List.mem l (subterms m)

(** Defn 1.4.1 FT, the set of free variables of a λ-term *)

let fv m =
  let rec aux binder_depth = function
    | Var x -> if x > binder_depth then [x] else []
    | App (m, n) -> aux binder_depth m @ aux binder_depth n
    | Abs m -> aux (binder_depth + 1) m
  in
  aux 0 m
;;

(** Defn 1.4.3 Closed λ-term; combinator; Λ⁰ *)

let is_closed m = fv m = []
