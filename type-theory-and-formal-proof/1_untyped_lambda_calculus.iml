(** Defn 1.3.2 The set Λ of all λ-terms **)

(** Vars *)

type var =
  { name : string
  ; idx : int (** De Bruijn index for this name *)
  }

let pp_var fmt v =
  if v.idx = 1 then
    CCFormat.fprintf fmt "%s" v.name
  else
    CCFormat.fprintf fmt "%s/%a" v.name Z.pp_print v.idx
[@@program];;
#install_printer pp_var;;

let v ?(i=1) x =
  { name = x; idx = i }

let valid_name = function
  | "x" | "y" | "z" -> true
  | _ -> false

let valid_var v =
  v.idx > 0
  (* un-comment for readable counterexamples *)
  (* && v.idx < 2 && valid_name v.name *)

(** Terms *)

type term =
  | Var of var
  | App of term * term
  | Abs of string * term

let rec pp_term fmt = function
  | Var v -> pp_var fmt v
  | App (m, n) -> CCFormat.fprintf fmt "(@[%a@]) (@[%a@])" pp_term m pp_term n
  | Abs (x, m) -> CCFormat.fprintf fmt "λ%s. @[%a@]" x pp_term m
[@@program];;
#install_printer pp_term;;

let var ?i x =
  Var (v ?i x)

let app m n = App (m, n)

let lam x m = Abs (x, m)

let rec valid_term = function
  | Var v -> valid_var v
  | App (m, n) -> valid_term m && valid_term n
  | Abs (x, m) ->
    (* un-comment for readable counterexamples *)
    (* valid_name x && *)
    valid_term m

(** Defn 1.3.5 Multiset of subterms *)
let rec subterms t =
  match t with
  | Var _ -> [t]
  | App (m, n) -> t :: subterms m @ subterms n
  | Abs (_, m) -> t :: subterms m
;;

(** Lemma 1.3.6 *)

(** (1) (Reflexivity) For all λ-terms M, we have M ∈ subterms M*)

lemma subterms_refl m =
  List.mem m (subterms m)
;;

lemma mem_append_l x xs ys =
   List.mem x xs ==> List.mem x (xs @ ys)
[@@auto][@@rw]
;;

lemma mem_append_r y xs ys =
   List.mem y ys ==> List.mem y (xs @ ys)
[@@auto][@@rw]
;;

lemma mem_append_b x xs ys =
   List.mem x (xs @ ys) ==> List.mem x xs || List.mem x ys
[@@auto][@@fc]
;;

(** (2) (Transitivity) If L ∈ subterms M and M ∈ subterms N, then L ∈ subterms N *)

lemma subterms_trans l m n =
  List.mem l (subterms m) && List.mem m (subterms n)
  ==>
  List.mem l (subterms n)
[@@auto]
;;

(** Defn 1.3.8 Proper subterm *)

let proper_subterm l m =
  l <> m && List.mem l (subterms m)

(** Defn 1.4.1 FT, the set of free variables of a λ-term *)

let free_vars m =
  let rec aux binder_depths = function
    | Var v ->
      let d = Map.get v.name binder_depths in
      if v.idx > d then [ { v with idx = v.idx - d } ] else []
    | App (m, n) -> aux binder_depths m @ aux binder_depths n
    | Abs (x, m) -> aux (binder_depths |> Map.add x (Map.get x binder_depths + 1)) m
  in
  aux (Map.const 0) m
;;

free_vars (lam "x" (var "y"));;
free_vars (lam "x" (var "x" ~i:2));;

let rec is_free_var v = function
  | Var u -> v = u
  | App (m, n) -> is_free_var v m || is_free_var v n
  | Abs (x, m) when v.name = x -> is_free_var { v with idx = v.idx + 1} m
  | Abs (_, m) -> is_free_var v m
[@@adm 1i]

(** Defn 1.4.3 Closed λ-term; combinator; Λ⁰ *)

let is_closed m = free_vars m = []

(** Defn 1.6.1 Substitution *)

let rec shift x d c =
  function
  | Var v when v.name = x ->
    Var { v with idx = if v.idx < c then v.idx else v.idx + d }
  | Var v -> Var v
  | App (m, n) -> App (shift x d c m, shift x d c n)
  | Abs (y, m) when x = y ->
    Abs (y, shift x d (c + 1) m)
  | Abs (y, m) ->
    Abs (y, shift x d c m)

let rec substitute x n m =
  match m with
  | Var v when v = x -> n
  | Var v -> Var v
  | App (m', n') ->
    App (substitute x n m', substitute x n n')
  | Abs (y, m') when x.name = y ->
    Abs (y, substitute { x with idx = x.idx + 1 } (shift y 1 0 n) m')
  | Abs (y, m') ->
    Abs (y, substitute x (shift y 1 0 n) m')
[@@adm m]
;;

substitute (v "x") (var "y") (lam "y" (var "x"));;

(** Lemma 1.6.5 *)
(* TODO *)

lemma substitute_commutes x y m n l =
  valid_var x && valid_var y &&
  valid_term m && valid_term n && valid_term l &&
  x <> y &&
  not (is_free_var x l) ==>
  (m |> substitute x n |> substitute y l)
  =
  (m |> substitute y l |> substitute x (n |> substitute y l))
[@@auto]
;;

(** Defn 1.8.1 One-step β-reduction *)

let rec beta_reduce_one_step = function
  | App (Abs (x, m), n) -> substitute (v x) n m
  | Var x -> Var x
  | App (m, n) ->
    (* reduce the lhs first *)
    let m' = beta_reduce_one_step m in
    if m = m' then
      App (m, beta_reduce_one_step n)
    else
      App (m', n)
  | Abs (x, m) -> Abs (x, beta_reduce_one_step m)
;;

(** Examples 1.8.2 *)

lemma ex_1_8_2_1 n =
  let x = var "x" in
  let y = var "y" in
  (app (lam "x" (app x (app x y))) n |> beta_reduce_one_step) = app n (app n y)
;;
lemma ex_1_8_2_2 n =
  let x, y, z, v = var "x", var "y", var "z", var "v" in
  (app (lam "x" (app (lam "y" (app y x)) z)) v |> beta_reduce_one_step)
  = app (lam "y" (app y v)) z
;;

(** Defn 1.8.3 β-reduction (zero-or-more-step) *)

(* TODO *)
(* let rec beta_reduce m = *)
(*   let m' = beta_reduce_one_step m in *)
(*   if m = m' then *)
(*     m *)
(*   else *)
(*     beta_reduce m' *)
