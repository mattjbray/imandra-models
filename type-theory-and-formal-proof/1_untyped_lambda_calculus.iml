(** Defn 1.3.2 The set Λ of all λ-terms **)

type term =
  | Var of string * int
  | App of term * term
  | Abs of string * term

(** Defn 1.3.5 Multiset of subterms *)
let rec subterms t =
  match t with
  | Var _ -> [t]
  | App (m, n) -> t :: subterms m @ subterms n
  | Abs (_, m) -> t :: subterms m
;;

(** Lemma 1.3.6 *)

(** (1) (Reflexivity) For all λ-terms M, we have M ∈ subterms M*)

lemma subterms_refl m =
  List.mem m (subterms m)
;;

lemma mem_append_l x xs ys =
   List.mem x xs ==> List.mem x (xs @ ys)
[@@auto][@@rw]
;;

lemma mem_append_r y xs ys =
   List.mem y ys ==> List.mem y (xs @ ys)
[@@auto][@@rw]
;;

lemma mem_append_b x xs ys =
   List.mem x (xs @ ys) ==> List.mem x xs || List.mem x ys
[@@auto][@@fc]
;;

(** (2) (Transitivity) If L ∈ subterms M and M ∈ subterms N, then L ∈ subterms N *)

lemma subterms_trans l m n =
  List.mem l (subterms m) && List.mem m (subterms n)
  ==>
  List.mem l (subterms n)
[@@auto]
;;

(** Defn 1.3.8 Proper subterm *)

let proper_subterm l m =
  l <> m && List.mem l (subterms m)

(** Defn 1.4.1 FT, the set of free variables of a λ-term *)

let free_vars m =
  let rec aux binder_depths = function
    | Var (x, i) ->
      let d = Map.get x binder_depths in
      if i > d then [x, i - d] else []
    | App (m, n) -> aux binder_depths m @ aux binder_depths n
    | Abs (x, m) -> aux (binder_depths |> Map.add x (Map.get x binder_depths + 1)) m
  in
  aux (Map.const 0) m
;;

free_vars (Abs ("x", (Var ("x", 1))))
;;

(** Defn 1.4.3 Closed λ-term; combinator; Λ⁰ *)

let is_closed m = free_vars m = []

(** Defn 1.6.1 Substitution *)

let rec shift d c =
  function
  | Var k ->
    Var (if k < c then k else k + d)
  | App (m, n) -> App (shift d c m, shift d c n)
  | Abs m -> Abs (shift d (c + 1) m)

let rec substitute x n m =
  match m with
  | Var y when x = y -> n
  | Var y -> Var y
  | App (m', n') -> App (substitute x n m', substitute x n n')
  | Abs m' -> Abs (substitute (x + 1) (shift 1 0 n) m')
[@@adm m]

(** Lemma 1.6.5 *)

let rec valid_term = function
  | Var x -> x > 0
  | App (m, n) -> valid_term m && valid_term n
  | Abs m -> valid_term m
;;

lemma substitute_commutes x y m n l =
   x > 0 && y > 0 &&
   valid_term m && valid_term n && valid_term l &&
   x <> y && not (List.mem x (free_vars l)) ==>
   (m |> substitute x n |> substitute y l)
   =
   (m |> substitute y l |> substitute x (n |> substitute y l))
;;
