module Spin = struct
  type direction = Up | Down

  let reverse_direction = function | Up -> Down | Down -> Up

  type t = { magnitude : Q.t; direction : direction }

  let make ?(direction=Up) magnitude = { magnitude; direction}

  let magnitude s = s.magnitude

  let reverse t = { t with direction = reverse_direction t.direction }

  let (+) t1 t2 =
    let s1 = Real.(t1.magnitude * match t1.direction with | Up -> 1.0 | Down -> (-1.0)) in
    let s2 = Real.(t2.magnitude * match t2.direction with | Up -> 1.0 | Down -> (-1.0)) in
    let magnitude = Real.(s1 + s2) in
    let direction = if Real.(magnitude < 0.0) then Down else Up in
    let magnitude = Real.abs magnitude in
    { magnitude; direction }
end

type w_type = Plus | Neg

type vector_boson =
  | Gluon
  | Photon
  | W of w_type
  | Z

type scalar_boson =
  | Higgs

type boson =
  | Vector of vector_boson
  | Scalar of scalar_boson

module Quark = struct
  type flavor = Up | Down | Charm | Strange | Top | Bottom

  type flavor_type = Up | Down

  let flavor_type : flavor -> flavor_type = function
    | Up | Charm | Top -> Up
    | Down | Strange | Bottom -> Down

  type color = Red | Green | Blue

  type t =
    { flavor : flavor
    ; color : color
    ; spin_dir : Spin.direction
    }

  let make ?(spin_dir=Spin.Up) ?(color=Red) flavor =
    { flavor; color; spin_dir }

  let up = make Up
  let down = make Down
  let charm = make Charm
  let strange = make Strange
  let top = make Top
  let bottom = make Bottom

  let flavor t = t.flavor
  let color t = t.color

  let spin t = Spin.make ~direction:t.spin_dir 0.5

  let charge t =
    match flavor_type t.flavor with
    | Up -> Real.(2.0 / 3.0)
    | Down -> Real.(-1.0 / 3.0)

  let absorb boson t =
    match boson with
    | Scalar Higgs
    | Vector Gluon
    | Vector Photon
    | Vector Z
    -> [ (Some boson, t) ] (* No interaction *)
    | Vector (W Plus) ->
      begin match flavor_type t.flavor with
      | Down ->
          [ (Some boson, t) (* No interaction *)
          ; (None, { t with spin_dir = Spin.reverse_direction t.spin_dir; flavor = Up })
          ; (None, { t with spin_dir = Spin.reverse_direction t.spin_dir; flavor = Charm })
          ; (None, { t with spin_dir = Spin.reverse_direction t.spin_dir; flavor = Top })
          ]
      | Up ->
          [ (Some boson, t) (* No interaction *)
          ]
      end
    | Vector (W Neg) ->
      begin match flavor_type t.flavor with
      | Down ->
          [ (Some boson, t) (* No interaction *)
          ]
      | Up ->
          [ (Some boson, t) (* No interaction *)
          ; (None, { t with spin_dir = Spin.reverse_direction t.spin_dir; flavor = Down })
          ; (None, { t with spin_dir = Spin.reverse_direction t.spin_dir; flavor = Strange })
          ; (None, { t with spin_dir = Spin.reverse_direction t.spin_dir; flavor = Bottom })
          ]
      end
end
;;

(** If the boson is absorbed, the quark's spin is reversed. *)
verify (fun boson quark ->
    let outcomes = Quark.absorb boson quark in
    outcomes |> List.for_all (fun (b, q) ->
        match b with
        | Some _ -> Quark.spin q = Quark.spin quark
        | None -> Quark.spin q = Spin.reverse (Quark.spin quark)
      )
  );;

(** If the boson is absorbed, Up-type quarks become Down-type quarks, and vice versa. *)
verify (fun boson quark ->
    let outcomes = Quark.absorb boson quark in
    outcomes |> List.for_all (fun (b, q) ->
        match b with
        | Some _ -> Quark.flavor q = Quark.flavor quark
        | None ->
          begin match (Quark.flavor_type (Quark.flavor quark), Quark.flavor_type (Quark.flavor q)) with
            | Down, Up
            | Up, Down -> true
            | _ -> false
          end
      )
  );;

module Lepton = struct
  type l =
    | Electron | Muon | Tau

  type t =
    { l : l
    ; is_neutrino : bool
    }
end

(* type fermion = *)
(*   | Quark of quark *)
(*   | Lepton of lepton *)

(* type family = *)
(*   | Fermion of fermion *)
(*   | Boson of boson *)


module Baryon = struct
    type t =
      { q1 : Quark.t; q2: Quark.t; q3: Quark.t }

    let make q1 q2 q3 = { q1; q2; q3 }

    let is_valid t =
      let c1 = Quark.color t.q1 in
      let c2 = Quark.color t.q2 in
      let c3 = Quark.color t.q3 in
      c1 <> c2 && c2 <> c3 && c1 <> c3

    let spin t =
      Spin.(Quark.spin t.q1 + Quark.spin t.q2 + Quark.spin t.q3)

    let charge t =
      Real.(Quark.charge t.q1 + Quark.charge t.q2 + Quark.charge t.q3)
end
;;

verify (fun baryon ->
    Baryon.is_valid baryon ==>
    let s = Spin.magnitude (Baryon.spin baryon) in
    List.mem s [ 1.5; 0.5 ]
  );;

verify (fun baryon ->
    Baryon.is_valid baryon ==>
    let c = Baryon.charge baryon in
    List.mem c [ 2.0; 1.0; 0.0; -1.0 ]
  );;


module Meson = struct
  type t =
    { q: Quark.t; anti_q: Quark.t }

  let make q anti_q = { q; anti_q }

  let spin t =
    Spin.(Quark.spin t.q + Quark.spin t.anti_q)

  let charge t =
    Real.(Quark.charge t.q - Quark.charge t.anti_q)
end
;;

verify (fun meson ->
    let s = Spin.magnitude (Meson.spin meson) in
    List.mem s [ 0.0; 1.0 ]
  );;

verify (fun meson ->
    let c = Meson.charge meson in
    List.mem c [ 1.0; 0.0; -1.0 ]
  );;
