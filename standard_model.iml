module Spin = struct
  type direction = Up | Down

  let reverse_direction = function | Up -> Down | Down -> Up

  type t = { magnitude : Q.t; direction : direction }

  let make ?(direction=Up) magnitude = { magnitude; direction}

  let magnitude s = s.magnitude

  let reverse t = { t with direction = reverse_direction t.direction }

  let (+) t1 t2 =
    let s1 = Real.(t1.magnitude * match t1.direction with | Up -> 1.0 | Down -> (-1.0)) in
    let s2 = Real.(t2.magnitude * match t2.direction with | Up -> 1.0 | Down -> (-1.0)) in
    let magnitude = Real.(s1 + s2) in
    let direction = if Real.(magnitude < 0.0) then Down else Up in
    let magnitude = Real.abs magnitude in
    { magnitude; direction }
end

module Boson = struct
  type w_type = Plus | Neg

  type vector_boson =
    | Gluon
    | Photon
    | W of w_type
    | Z

  type scalar_boson =
    | Higgs

  type boson =
    | Vector of vector_boson
    | Scalar of scalar_boson

  type t =
    { boson_t : boson
    ; spin_dir : Spin.direction
    }

  let make ~boson_t ~spin_dir () =
    { boson_t; spin_dir }

  let boson_t t = t.boson_t
  let spin t = Spin.make ~direction:t.spin_dir 1.0
end

module Quark = struct
  type flavor = Up | Down | Charm | Strange | Top | Bottom

  type flavor_type = Up | Down

  let flavor_type : flavor -> flavor_type = function
    | Up | Charm | Top -> Up
    | Down | Strange | Bottom -> Down

  type color = Red | Green | Blue

  type t =
    { flavor : flavor
    ; color : color
    ; spin_dir : Spin.direction
    }

  let make ?(spin_dir=Spin.Up) ?(color=Red) flavor =
    { flavor; color; spin_dir }

  let up = make Up
  let down = make Down
  let charm = make Charm
  let strange = make Strange
  let top = make Top
  let bottom = make Bottom

  let flavor t = t.flavor
  let color t = t.color

  let spin t = Spin.make ~direction:t.spin_dir 0.5

  let charge t =
    match flavor_type t.flavor with
    | Up -> Real.(2.0 / 3.0)
    | Down -> Real.(-1.0 / 3.0)

  let reverse_spin t =
    { t with spin_dir = Spin.reverse_direction t.spin_dir }

  let absorb boson t =
    match Boson.boson_t boson with
    | Scalar Higgs
    | Vector Gluon
    | Vector Photon
    | Vector Z
    -> [ (Some boson, t) ] (* No interaction *)
    | Vector (W Plus) ->
      begin match flavor_type t.flavor with
      | Down ->
          [ (Some boson, t) (* No interaction *)
          ; (None, { t with flavor = Up } |> reverse_spin)
          ; (None, { t with flavor = Charm } |> reverse_spin)
          ; (None, { t with flavor = Top } |> reverse_spin)
          ]
      | Up ->
          [ (Some boson, t) (* No interaction *)
          ]
      end
    | Vector (W Neg) ->
      begin match flavor_type t.flavor with
      | Down ->
          [ (Some boson, t) (* No interaction *)
          ]
      | Up ->
          [ (Some boson, t) (* No interaction *)
          ; (None, { t with flavor = Down } |> reverse_spin)
          ; (None, { t with flavor = Strange } |> reverse_spin)
          ; (None, { t with flavor = Bottom } |> reverse_spin)
          ]
      end

  let emit t : (Boson.t option * t) list =
    match flavor_type t.flavor with
    | Up ->
      let boson =
        Boson.make ()
          ~boson_t:(Vector (W Plus)) ~spin_dir:t.spin_dir
      in
      [ (None, t) (* No emission *)
      ; (Some boson, { t with flavor = Down } |> reverse_spin)
      ; (Some boson, { t with flavor = Strange } |> reverse_spin)
      ; (Some boson, { t with flavor = Bottom } |> reverse_spin)
      ]
    | Down ->
      let boson =
        Boson.make ()
          ~boson_t:(Vector (W Neg)) ~spin_dir:t.spin_dir
      in
      [ (None, t) (* No emission *)
      ; (Some boson, { t with flavor = Up } |> reverse_spin)
      ; (Some boson, { t with flavor = Charm } |> reverse_spin)
      ; (Some boson, { t with flavor = Top } |> reverse_spin)
      ]
end
;;

(** If the boson is absorbed, the quark's spin is reversed. *)
verify (fun boson quark ->
    let outcomes = Quark.absorb boson quark in
    outcomes |> List.for_all (fun (b, q) ->
        match b with
        | Some _ -> Quark.spin q = Quark.spin quark
        | None -> Quark.spin q = Spin.reverse (Quark.spin quark)
      )
  );;

(** If the boson is absorbed, Up-type quarks become Down-type quarks, and vice versa. *)
verify (fun boson quark ->
    let outcomes = Quark.absorb boson quark in
    outcomes |> List.for_all (fun (b, q) ->
        match b with
        | Some _ -> Quark.flavor q = Quark.flavor quark
        | None ->
          begin match (Quark.flavor_type (Quark.flavor quark), Quark.flavor_type (Quark.flavor q)) with
            | Down, Up
            | Up, Down -> true
            | _ -> false
          end
      )
  );;

(** If a boson is emitted, spin is conserved. *)
verify (fun quark ->
    let outcomes = Quark.emit quark in
    outcomes |> List.for_all (fun (b, q) ->
        match b with
        | Some boson -> Quark.spin quark = Spin.(Quark.spin q + Boson.spin boson)
        | None -> Quark.spin quark = Quark.spin q
      )
  );;

(** If a boson is emitted, Up-type quarks become Down-type quarks, and vice versa. *)
verify (fun boson quark ->
    let outcomes = Quark.emit quark in
    outcomes |> List.for_all (fun (b, q) ->
        match b with
        | Some _ ->
          begin match
              ( Quark.flavor_type (Quark.flavor quark)
              , Quark.flavor_type (Quark.flavor q)
              )
            with
            | Down, Up
            | Up, Down -> true
            | _ -> false
          end
        | None -> Quark.flavor quark = Quark.flavor q
      )
  );;


module Lepton = struct
  type l =
    | Electron | Muon | Tau

  type t =
    { l : l
    ; is_neutrino : bool
    }
end

(* type fermion = *)
(*   | Quark of quark *)
(*   | Lepton of lepton *)

(* type family = *)
(*   | Fermion of fermion *)
(*   | Boson of boson *)


module Baryon = struct
    type t =
      { q1 : Quark.t; q2: Quark.t; q3: Quark.t }

    let make q1 q2 q3 = { q1; q2; q3 }

    let is_valid t =
      let c1 = Quark.color t.q1 in
      let c2 = Quark.color t.q2 in
      let c3 = Quark.color t.q3 in
      c1 <> c2 && c2 <> c3 && c1 <> c3

    let spin t =
      Spin.(Quark.spin t.q1 + Quark.spin t.q2 + Quark.spin t.q3)

    let charge t =
      Real.(Quark.charge t.q1 + Quark.charge t.q2 + Quark.charge t.q3)
end
;;

verify (fun baryon ->
    Baryon.is_valid baryon ==>
    let s = Spin.magnitude (Baryon.spin baryon) in
    List.mem s [ 1.5; 0.5 ]
  );;

verify (fun baryon ->
    Baryon.is_valid baryon ==>
    let c = Baryon.charge baryon in
    List.mem c [ 2.0; 1.0; 0.0; -1.0 ]
  );;


module Meson = struct
  type t =
    { q: Quark.t; anti_q: Quark.t }

  let make q anti_q = { q; anti_q }

  let spin t =
    Spin.(Quark.spin t.q + Quark.spin t.anti_q)

  let charge t =
    Real.(Quark.charge t.q - Quark.charge t.anti_q)
end
;;

verify (fun meson ->
    let s = Spin.magnitude (Meson.spin meson) in
    List.mem s [ 0.0; 1.0 ]
  );;

verify (fun meson ->
    let c = Meson.charge meson in
    List.mem c [ 1.0; 0.0; -1.0 ]
  );;
